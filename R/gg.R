#' Generate a ggplot2 representation of an SOmap object
#'
#' Note: this function is still experimental! Use at your own risk.
#'
#' @param ... : one or more objects as returned by \code{SOmap}, \code{SOmap2}, \code{SOmanagement}, or \code{SOmap_auto}
#'
#' @return An object of class "SOmap_gg", "SOmanagement_gg", or "SOmap_auto_gg". Printing or plotting this object will cause it to generate a ggplot2 object, which will be returned to the user. If this object is printed or plotted (e.g. to the console) then it will be displayed in the current graphics device as is usual for ggplot2 objects.
#'
#' @examples
#' \dontrun{
#'   ## generate a SOmap obkect
#'   p <- SOmap2(trim = -45, iwc = TRUE, iwc_labels = TRUE, graticules = TRUE, fronts = TRUE,
#'               mpa = TRUE, mpa_labels = TRUE)
#'
#'   ## convert this to a ggplot2-based representation
#'   pg <- SOgg(p)
#'
#'   ## display it
#'   pg
#'
#'   ## we can see that this object has a bunch of ggplot code embedded inside of it
#'   str(pg)
#'
#'   ## and that code can be modified if desired
#'   ## e.g. change the bathymetry colours
#'   pg$scale_fill[[1]]$plotargs$colours <- topo.colors(21)
#'   ## plot it
#'   pg
#'
#'   ## when the print or plot method is called on pg, it creates an actual ggplot2
#'   ##  object, which we can capture and modify
#'   pg_gg <- plot(pg)
#'   class(pg_gg)
#'
#'   ## modifying this is done in the same way any other ggplot object is modified
#'   ## e.g. add a new scale_fill_gradientn to override the existing one
#'   pg_gg + ggplot2::scale_fill_gradientn(colours = heat.colors(21))
#' }
#'
#' @export
SOgg <- function(...) {
    x <- list(...)
    if (length(x) == 1) {
        x <- x[[1]]
        if (inherits(x, "SOmap")) {
            SOgg_notauto(x)
        } else if (inherits(x, "SOmap_management")) {
            SOgg_management(x)
        } else if (inherits(x, "SOmap_auto")) {
            SOgg_auto(x)
        } else {
            stop("x must be an SOmap/SOmap_auto/SOmanagement object as generated by SOmap, SOmap2, SOmanagement, or SOmap_auto")
        }
    } else if (length(x) < 1) {
        NULL
    } else {
        ## apply SOgg to each item in turn
        ## but note that if we have passed a SOmap_management object, it won't have projection or trim components
        ## we should use whatever has been passed in the other object(s)
        utrim <- unique(unlist(lapply(x, function(z) z$trim)))
        if (!is.null(utrim) && length(utrim) == 1) {
            ## one unique value of trim
            for (xi in seq_along(x)) x[[xi]]$trim <- utrim
        }
        uprojection <- unique(unlist(lapply(x, function(z) z$projection)))
        if (!is.null(uprojection) && length(uprojection) == 1) {
            ## one unique value of projection
            for (xi in seq_along(x)) x[[xi]]$projection <- uprojection
        }
        ## need to do something sensible here if we have conflicting trim or projection entries in different objects
        uglymerge(lapply(x, SOgg))
    }
}
## TODO: rather than gg-ifying then merging, do the merge then gg-ify. That function would probably be useful to users in its own right
##  (see https://github.com/AustralianAntarcticDivision/SOmap/issues/45

uglymerge <- function(xl) {
    out <- xl[[1]]
    for (ii in seq_along(xl)[-1]) {
        this <- xl[[ii]]
        nms <- setdiff(names(this), c("plot_sequence"))
        for (nn in nms) out[[nn]] <- this[[nn]]
        out$plot_sequence <- c(setdiff(out$plot_sequence, this$plot_sequence), this$plot_sequence)
    }
    out
}

#' @method plot SOmap_gg
#' @export
plot.SOmap_gg <- function (x, y, ...) {
    plot_all_gg(x)
}

#' @method print SOmap_gg
#' @export
print.SOmap_gg <- function(x, ...) {
    print(plot(x))
}

## iterate through the object's plot_sequence vector, running the plotfun with plotargs for each
plot_all_gg <- function(x) {
    assert_that(inherits(x, c("SOmap_gg", "SOmap_auto_gg")))
    ## interate through each plottable element in turn
    p <- NULL
    for (toplot in intersect(x$plot_sequence, names(x))) {
        allpf <- x[[toplot]] ## all the stuff to plot for this element
        ## either a SO_plotter object, or a list thereof
        ## if it's just one, put it in a list
        if (inherits(allpf, "SO_plotter")) allpf <- list(allpf)
        if (!all(vapply(allpf, inherits, "SO_plotter", FUN.VALUE = TRUE))) {
            warning("plotting behaviour for '", toplot, "' should be specified by an SO_plotter object or list of such objects, ignoring")
            next
        }
        ## evaluate each of these plotfuns
        for (thispf in allpf[seq_along(allpf)]) {
            thisfun <- thispf$plotfun
            this_plotargs <- thispf$plotargs
            thisp <- if (is.character(thisfun)) do.call(eval(parse(text = thisfun)), this_plotargs) else do.call(thisfun, this_plotargs)
            p <- if (is.null(p)) thisp else p + thisp
        }
    }
    p
}

## NOTE, the "parse = TRUE/FALSE" args to geom_text and geom_sf_text seem fragile, need better user control

## gg-ifier for SOmap objects, not SOmap_auto. Any management layers will be passed so SOgg_management for gg-ifying
SOgg_notauto <- function(x) {
    if (!inherits(x, "SOmap")) stop("x must be an SOmap object as generated by SOmap or SOmap2")
    myext <- extent(x$target)
    ## plot bathymetry
    bdf <- raster::as.data.frame(raster::trim(SOmap::latmask(x$bathy[[1]]$plotargs$x, latitude = x$trim)), xy = TRUE)
    names(bdf)[3] <- "Depth"

    out <- x[intersect(names(x), c("projection", "target", "straight", "trim"))]
    out$init <- SO_plotter(plotfun = "ggplot2::ggplot", plotargs = list(data = bdf, mapping = aes_string(x = "x", y = "y")))
    out$bathy <- SO_plotter(plotfun = "ggplot2::geom_raster", plotargs = list(mapping = aes_string(fill = "Depth")))
    out$coord <- SO_plotter(plotfun = coord_sf, plotargs = list(default = TRUE))
    out$plot_sequence <- c("init", "bathy", "coord")

    out$scale_fill <- SO_plotter(plotfun = "ggplot2::scale_fill_gradientn", plotargs = list(colours = x$bathy[[1]]$plotargs$col, na.value = "#FFFFFF00", guide = if (!x$straight) FALSE else "colourbar"))
    out$plot_sequence <- c(out$plot_sequence, "scale_fill")

    if (!is.null(x$bathy_legend) && !x$straight) {
        suppressMessages(thecolors <- fortify(x$bathy_legend$legend_fill$plotargs$x))
        ## exclude the last two entries here, they are the outer (long) borders
        theticks <- x$bathy_legend$ticks$plotargs$x
        theticks <- theticks[seq_len(nrow(theticks)-2), ]
        suppressMessages(theticks <- fortify(theticks))
        suppressMessages(themask <- fortify(x$bathy_legend$graticules$plotargs$x))
        thecolors$cols <- as.numeric(thecolors$id)
        legend_as_annotation <- FALSE
        if (legend_as_annotation) {
            ## experimental, not yet used
            out$bathy_legend <- c(SO_plotter(plotfun = "ggplot2::annotate", plotargs = list(geom = "path", x = theticks$long, y = theticks$lat, group = theticks$group, col = x$bathy_legend$ticks$plotargs$col, size = 1)),
                                  SO_plotter(plotfun = "ggplot2::annotate", plotargs = list(geom = "polygon", x = thecolors$long, y = thecolors$lat, group = thecolors$group,  fill = NA, col = x$bathy_legend$ticks$plotargs$col, size = 1)))
            out$bathy_legend <- c(out$bathy_legend, unlist(lapply(seq_along(x$bathy_legend$legend_fill$plotargs$col), function(ii) SO_plotter(plotfun = "ggplot2::annotate", plotargs = list(geom = "polygon", x = thecolors$long[thecolors$cols == ii], y = thecolors$lat[thecolors$cols == ii], fill = x$bathy_legend$legend_fill$plotargs$col[ii], col = NA))), recursive = FALSE))
            temp <- as.data.frame(x$bathy_legend$labels$plotargs$x)
            out$bathy_legend <- c(out$bathy_legend, SO_plotter(plotfun = "ggplot2::annotate", plotargs = list(geom = "text", x = temp$lon, y = temp$lat, label = temp$a, size = 2)))
        } else {
            out$bathy_legend <- c(SO_plotter(plotfun = "ggplot2::geom_line", plotargs = list(data = theticks, aes_string(x = "long", y = "lat", group = "group"), col = x$bathy_legend$ticks$plotargs$col, size = 1)),
                                  SO_plotter(plotfun = "ggplot2::geom_polygon", plotargs = list(data = thecolors, aes_string(x = "long", y = "lat", group = "group"),  fill = NA, col = x$bathy_legend$ticks$plotargs$col, size = 1)))
            out$bathy_legend <- c(out$bathy_legend, unlist(lapply(seq_along(x$bathy_legend$legend_fill$plotargs$col), function(ii) SO_plotter(plotfun = "ggplot2::geom_polygon", plotargs = list(data = thecolors[thecolors$cols == ii, ], aes_string(x = "long", y = "lat", group = "group"), fill = x$bathy_legend$legend_fill$plotargs$col[ii], col = NA))), recursive = FALSE))
            out$bathy_legend <- c(out$bathy_legend, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = as.data.frame(x$bathy_legend$labels$plotargs$x), aes_string(x = "lon", y = "lat", label = "a"), size = 2)))
        }
        out$plot_sequence <- c(out$plot_sequence, "bathy_legend")
    }

    ## buffer to use for cropping things back to our extent of interest
    buf <- make_buf(x$trim+2, x$projection)

    if (!is.null(x$coastline)) {
        ## the coastline data has to be trimmed to our northernmost latitude
        ## masking (using e.g. x$outer_mask) is likely to be problematic because of z-ordering
        ## TODO check that this trimming is robust
        this <- suppressWarnings(sf::st_intersection(buf, x$coastline[[1]]$plotargs$x))
        out$coastline <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, fill = x$coastline[[1]]$plotargs$col, col = x$coastline[[1]]$plotargs$border, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "coastline")
    }
    if (!is.null(x$ice)) {
        ## TODO check that this trimming is robust
        this <- suppressWarnings(sf::st_intersection(buf, x$ice[[1]]$plotargs$x))
        out$ice <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, fill = x$ice[[1]]$plotargs$col, col = x$ice[[1]]$plotargs$border, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "ice")
    }

    ## fronts
    if (!is.null(x$fronts)) {
        this <- x$fronts[[1]]$plotargs$x
        this <- suppressWarnings(sf::st_intersection(buf, this))
        thiscol <- rep(x$fronts[[1]]$plotargs$col, ceiling(nrow(this)/length(x$fronts[[1]]$plotargs$col)))
        thiscol <- thiscol[seq_len(nrow(this))]
        out$fronts <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = thiscol, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "fronts")
    }

    ## Graticule grid
    if (!is.null(x$graticule)) {
        this <- fortify(x$graticule$main$plotargs$x)
        this <- this[this$long >= myext[1] & this$long <= myext[2] & this$lat >= myext[3] & this$lat <= myext[4], ]
        out$graticule <- SO_plotter(plotfun = "ggplot2::geom_path", plotargs = list(data = this, aes_string(x = "long", y = "lat", group = "group"), col = x$graticule$main$plotargs$col, linetype = x$graticule$main$plotargs$lty))
        if (!is.null(x$graticule$labels)) {
            this <- as.data.frame(x$graticule$labels$plotargs$x)
            this <- this[this$x >= myext[1] & this$x <= myext[2] & this$y >= myext[3] & this$y <= myext[4], ]
            out$graticule <- c(out$graticule, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = this, aes_string(label = "lab"), parse = TRUE, col = x$graticule$labels$plotargs$col)))##, cex = x$graticule$labels$plotargs$cex)
            ## can't use cex on that, it gets translated to a size aesthetic, which is an absolute not relative size
        }
        out$plot_sequence <- c(out$plot_sequence, "graticule")
    }

    out$axis_labels <- SO_plotter(plotfun = "ggplot2::labs", plotargs = list())
    out$plot_sequence <- c(out$plot_sequence, "axis_labels")
    out$theme <- SO_plotter(plotfun = "ggplot2::theme", plotargs = list(axis.title = element_blank(),
                                                                        axis.text.x = element_blank(), axis.ticks.x = element_blank(),
                                                                        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
                                                                        panel.border = element_blank(),
                                                                        panel.background = element_blank()))
    out$plot_sequence <- c(out$plot_sequence, "theme")


    ## process the ccamlr_statistical_areas, ccamlr_ssru etc components (if they exist) using SOgg_management
    temp <- SOgg_management(x)
    for (nn in setdiff(names(temp), "plot_sequence")) out[[nn]] <- temp[[nn]]
    out$plot_sequence <- c(out$plot_sequence, temp$plot_sequence)

    if (!is.null(x$border)) {
        suppressMessages(this <- fortify(x$border[[1]]$plotargs$x))
        this$col <- (as.numeric(this$id) %% length(x$border[[1]]$plotargs$col)) + 1
        out$border <- NULL
        for (ii in seq_along(x$border[[1]]$plotargs$col)) {
            out$border <- c(out$border, SO_plotter(plotfun = "ggplot2::geom_polygon", plotargs = list(data = this[this$col == ii, ], aes_string(x = "long", y = "lat", group = "group"), fill = x$border[[1]]$plotargs$col[ii], col = "black")))
        }
        out$plot_sequence <- c(out$plot_sequence, "border")
    }
    structure(out, class = "SOmap_gg")
}


## gg-ifier for SOmanagement objects
SOgg_management <- function(x, basemap) {
    ## this can be given an SOmap_management object, or an SOmap object (in which case it only extracts the management components
    if (!inherits(x, c("SOmap_management", "SOmap"))) stop("x must be an SOmap_management object as generated by SOmanagement")
    out <- list()

    have_warned <- FALSE
    thisproj <- NULL
    if ("projection" %in% names(x)) {
        thisproj <- x$projection
    } else if (!missing(basemap)) {
        thisproj <- basemap$projection
    } else {
        have_warned <- TRUE
        warning("to ensure correct cropping of layers, either need to be an SOmap object, or basemap to be supplied")
    }
    thistrim <- NULL
    if ("trim" %in% names(x)) {
        thistrim <- x$trim
    } else if (!missing(basemap)) {
        thistrim <- basemap$trim
    } else {
        if (!have_warned) warning("to ensure correct cropping of layers, either need to be an SOmap object, or basemap to be supplied")
    }
    ## buffer to use for cropping things back to our extent of interest
    if (is.null(thisproj) || is.null(thistrim)) {
        buf <- NULL
    } else {
        buf <- make_buf(x$trim+2, x$projection)
    }
    apply_buf <- function(thing) if (is.null(buf)) thing else suppressWarnings(sf::st_intersection(buf, thing))

    if (!is.null(x$ccamlr_statistical_areas)) {
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_statistical_areas$main$plotargs$x)))
        out$ccamlr_statistical_areas <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$ccamlr_statistical_areas$main$plotargs$border,  inherit.aes = FALSE, fill = NA))#fill = x$ccamlr_statistical_areas$main$plotargs$col)
        if (!is.null(x$ccamlr_statistical_areas$labels)) {
            temp <- x$ccamlr_statistical_areas[names(x$ccamlr_statistical_areas) %in% "labels"]
            for (templab in temp) {
                this <- templab$plotargs$x
                this <- suppressWarnings(apply_buf(sf::st_as_sf(this)))
                out$ccamlr_statistical_areas <- c(out$ccamlr_statistical_areas,
                                                  SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = "LongLabel"), parse = FALSE, col = templab$plotargs$col, size = 2, inherit.aes = FALSE)))
            }
        }
        out$plot_sequence <- c(out$plot_sequence, "ccamlr_statistical_areas")
    }


    if (!is.null(x$ccamlr_ssru)) {
        if (is.null(x$ccamlr_ssru$main$plotargs$col)) x$ccamlr_ssru$main$plotargs$col <- NA
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_ssru$main$plotargs$x)))
        out$ccamlr_ssru <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$ccamlr_ssru$main$plotargs$border, fill = x$ccamlr_ssru$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$ccamlr_ssru$labels)) {
            this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_ssru$labels$plotargs$x)))
            out$ccamlr_ssru <- c(out$ccamlr_ssru, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = as.character("Name")), parse = FALSE, col = x$ccamlr_ssru$labels$plotargs$col, size = 2, inherit.aes = FALSE)))##, cex = x$mpa$labels$cex, pos = x$mpa$labels$pos, offset = x$mpa$labels$offset)
        }
        out$plot_sequence <- c(out$plot_sequence, "ccamlr_ssru")
    }

    if (!is.null(x$ccamlr_ssmu)) {
        if (is.null(x$ccamlr_ssmu$main$plotargs$col)) x$ccamlr_ssmu$main$plotargs$col <- NA
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_ssmu$main$plotargs$x)))
        out$ccamlr_ssmu <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$ccamlr_ssmu$main$plotargs$border, fill = x$ccamlr_ssmu$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$ccamlr_ssmu$labels)) {
            this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_ssmu$labels$plotargs$x)))
            out$ccamlr_ssmu <- c(out$ccamlr_ssmu, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = as.character("ShortLabel")), parse = FALSE, col = x$ccamlr_ssmu$labels$plotargs$border, size = 2, inherit.aes = FALSE)))##, cex = x$mpa$labels$cex, pos = x$mpa$labels$pos, offset = x$mpa$labels$offset)
        }
        out$plot_sequence <- c(out$plot_sequence, "ccamlr_ssmu")
    }

    if (!is.null(x$iwc)) {
        pidx <- seq_along(x$iwc)
        if (!is.null(names(x$iwc))) pidx <- pidx[!names(x$iwc) %in% c("labels")] ## not labels here
        if (length(pidx) > 0) {
            this <- do.call(rbind, lapply(pidx, function(z) { out <- as.data.frame(x$iwc[[z]]$plotargs$x); out$id <- z; out}))
            names(this) <- c("x", "y", "id")
            out$iwc <- SO_plotter(plotfun = "ggplot2::geom_path", plotargs = list(data = this, aes_string(x = "x", y = "y", group = "id"), col = x$iwc[[pidx[1]]]$plotargs$col, inherit.aes = FALSE))
        }
        if (!is.null(x$iwc$labels)) {
            this <- suppressWarnings(apply_buf(sf::st_as_sf(x$iwc$labels$plotargs$x)))
            out$iwc <- c(out$iwc, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = "a.1"), parse = FALSE, col = x$iwc$labels$plotargs$col, size = 2, inherit.aes = FALSE)))
        }
        out$plot_sequence <- c(out$plot_sequence, "iwc")
    }

    if (!is.null(x$research_blocks)) {
        if (is.null(x$research_blocks$main$plotargs$col)) x$research_blocks$main$plotargs$col <- NA
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$research_blocks$main$plotargs$x)))
        out$research_blocks <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$research_blocks$main$plotargs$border, fill = x$research_blocks$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$research_blocks$labels)) {
            this <- x$research_blocks$labels$plotargs$x
            this <- suppressWarnings(apply_buf(sf::st_as_sf(this)))
            out$research_blocks <- c(out$research_blocks, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = as.character("GAR_Short_")), parse = FALSE, col = x$research_blocks$labels$plotargs$col, size = 2, inherit.aes = FALSE)))
        }
        out$plot_sequence <- c(out$plot_sequence, "research_blocks")
    }


    if (!is.null(x$sprfmo_research_blocks)) {
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$sprfmo_research_blocks[[1]]$plotargs$x)))
        that <- suppressWarnings(apply_buf(sf::st_as_sf(x$sprfmo_research_blocks[[2]]$plotargs$x)))
        out$sprfmo_research_blocks <- c(SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$sprfmo_research_blocks[[1]]$plotargs$col,  inherit.aes = FALSE)),
                                        SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = that, col = x$sprfmo_research_blocks[[2]]$plotargs$col,  inherit.aes = FALSE)))
        out$plot_sequence <- c(out$plot_sequence, "sprfmo_research_blocks")
    }

    if (!is.null(x$eez)) {
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$eez$main$plotargs$x)))
        out$eez <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$eez$main$plotargs$border, fill = x$eez$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$eez$labels)) {
            this <- x$eez$labels$plotargs$x
            this <- suppressWarnings(apply_buf(sf::st_as_sf(this)))
            out$eez <- c(out$eez, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = this, aes_string(label = "ShortLabel"), parse = FALSE,size = 2, col = x$eez$labels$plotargs$col, inherit.aes = FALSE)))##, cex = x$eez$labels$cex, pos = x$eez$labels$pos, offset = x$eez$labels$offset)
        }
        out$plot_sequence <- c(out$plot_sequence, "eez")
    }

    if (!is.null(x$mpa)) {
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$mpa$main$plotargs$x)))
        out$mpa <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$mpa$main$plotargs$border, fill = x$mpa$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$mpa$labels)) {
            this <- x$mpa$labels$plotargs$x
            this <- suppressWarnings(apply_buf(sf::st_as_sf(this)))
            out$mpa <- c(out$mpa, SO_plotter(plotfun = "ggplot2::geom_sf_text", plotargs = list(data = as.data.frame(this), aes_string(label = "ShortLabel"), parse = TRUE, col = x$mpa$labels$plotargs$col, size = 2, inherit.aes = FALSE)))##, cex = x$mpa$labels$cex, pos = x$mpa$labels$pos, offset = x$mpa$labels$offset)
        }
        out$plot_sequence <- c(out$plot_sequence, "mpa")
    }

    if (!is.null(x$ccamlr_planning_domains)) {
        this <- suppressWarnings(apply_buf(sf::st_as_sf(x$ccamlr_planning_domains$main$plotargs$x)))
        ## TODO fix that intersection, is slow because of complexity of coastline
        out$ccamlr_planning_domains <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, col = x$ccamlr_planning_domains$main$plotargs$border, fill = x$ccamlr_planning_domains$main$plotargs$col, inherit.aes = FALSE))
        if (!is.null(x$ccamlr_planning_domains$labels)) {
            ## this is horrible code
            temp <- x$ccamlr_planning_domains[names(x$ccamlr_planning_domains) %in% "labels"]
            crds <- as.data.frame(sp::coordinates(temp[[1]]$plotargs$x))
            names(crds) <- c("x", "y")
            crds$lab <- temp[[1]]$plotargs$x$labs
            out$ccamlr_planning_domains <- c(out$ccamlr_planning_domains, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = crds, aes_string(x = "x", y = "y", label = "lab"), parse = FALSE, col = temp[[1]]$plotargs$col, inherit.aes = FALSE, hjust = 0.5, vjust = 1)))
            crds$lab <- temp[[2]]$plotargs$x$labs1
            out$ccamlr_planning_domains <- c(out$ccamlr_planning_domains, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = crds, aes_string(x = "x", y = "y", label = "lab"), parse = FALSE, col = temp[[2]]$plotargs$col, inherit.aes = FALSE, hjust = 0.5, vjust = 0)))
            crds$lab <- temp[[3]]$plotargs$x$labs2
            out$ccamlr_planning_domains <- c(out$ccamlr_planning_domains, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = crds, aes_string(x = "x", y = "y", label = "lab"), parse = FALSE, col = temp[[3]]$plotargs$col, inherit.aes = FALSE, hjust = 0.5, vjust = 1)))
            crds$lab <- temp[[4]]$plotargs$x$labs7
            out$ccamlr_planning_domains <- c(out$ccamlr_planning_domains, SO_plotter(plotfun = "ggplot2::geom_text", plotargs = list(data = crds, aes_string(x = "x", y = "y", label = "lab"), parse = FALSE, col = temp[[4]]$plotargs$col, inherit.aes = FALSE, hjust = 0, vjust = 0.5)))
            ## the hjust/vjust settings here are a rough attempt to position the labels more nicely
            ## needs work
        }
        out$plot_sequence <- c(out$plot_sequence, "ccamlr_planning_domains")
    }
    structure(out, class = "SOmanagement_gg")
}

## gg-ifier for SOmap_auto objects
SOgg_auto <- function(x) {
    if (!inherits(x, "SOmap_auto")) stop("x must be an SOmap_auto object as generated by SOmap_auto")
    myext <- extent(x$target)
    ## plot bathymetry
    bdf <- raster::as.data.frame(x$bathy, xy = TRUE)
    names(bdf) <- c("Longitude","Latitude","Depth")

    out <- x[intersect(names(x), c("projection", "target", "straight", "trim"))]
    out$init <- SO_plotter(plotfun = "ggplot2::ggplot", plotargs = list(data = bdf, mapping = aes_string(x = "Longitude", y = "Latitude")))
    out$bathy <- SO_plotter(plotfun = "ggplot2::geom_raster", plotargs = list(mapping = aes_string(fill = "Depth")))
    out$coord <- SO_plotter(plotfun = coord_sf, plotargs = list(default = TRUE))
    out$plot_sequence <- c("init", "bathy", "coord")

    out$scale_fill <- SO_plotter(plotfun = "ggplot2::scale_fill_gradientn", plotargs = list(colours = x$bathy_palette, na.value = "#FFFFFF00"))
    out$plot_sequence <- c(out$plot_sequence, "scale_fill")

    if (!is.null(x$coastline)) {
        this <- suppressWarnings(sf::st_as_sf(x$coastline$data))
        out$coastline <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, fill = x$coastline$fillcol, col = x$coastline$linecol, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "coastline")
    }
    if (!is.null(x$ice)) {
        this <- suppressWarnings(sf::st_as_sf(x$ice$data))
        out$ice <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, fill = x$ice$fillcol, col = x$ice$linecol, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "ice")
    }
    if (x$contours) {
        this <- suppressWarnings(sf::st_as_sf(x$coastline$data))
        out$contours <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = this, fill = x$coastline$fillcol, col = x$coastline$linecol, inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "contours")

    }

    if (!is.null(x$graticule)) {
        out$graticule <- SO_plotter(plotfun = "ggplot2::geom_sf", plotargs = list(data = x$graticule, col = "grey", inherit.aes = FALSE))
        out$plot_sequence <- c(out$plot_sequence, "graticule")
    }

    if(!is.null(x$lines_data)) {
        out$lines_data <- SO_plotter(plotfun = "ggplot2::geom_line", plotargs = list(data = setNames(as.data.frame(x$lines_data), c("x", "y")), aes_string(x = "x", y = "y"), col = x$lcol, linetype = x$llty, size = x$llwd))
        out$plot_sequence <- c(out$plot_sequence, "lines_data")
    }

    if(!is.null(x$points_data)) {
        out$points_data <- SO_plotter(plotfun = "ggplot2::geom_point", plotargs = list(data = setNames(as.data.frame(x$points_data), c("x", "y")), aes_string(x = "x", y = "y"), col = x$pcol, shape = x$ppch, size = x$pcex))
        out$plot_sequence <- c(out$plot_sequence, "points_data")
    }

    out$theme <- SO_plotter(plotfun = "ggplot2::theme", plotargs = list(axis.title = element_blank(), panel.border = element_rect(color = "black", fill = NA), panel.background = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5)))
    out$plot_sequence <- c(out$plot_sequence, "theme")
    out$scale_x <- SO_plotter(plotfun = "ggplot2::scale_x_continuous", plotargs = list(expand = c(0, 0)))
    out$scale_y <- SO_plotter(plotfun = "ggplot2::scale_y_continuous", plotargs = list(expand = c(0, 0)))
    out$plot_sequence <- c(out$plot_sequence, "scale_x", "scale_y")

    structure(out, class = "SOmap_auto_gg")
}

#' @method plot SOmap_auto_gg
#' @export
plot.SOmap_auto_gg <- function (x, y, ...) {
    plot_all_gg(x)
}

#' @method print SOmap_auto_gg
#' @export
print.SOmap_auto_gg <- function(x, ...) {
    print(plot(x))
}
