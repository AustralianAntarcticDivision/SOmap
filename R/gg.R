#' Generate a ggplot2 representation of an SOmap object
#'
#' @param x SOmap: object as returned by \code{SOmap} or \code{SOmap2}
#'
#' @return A ggplot object
#'
#' @examples
#' \dontrun{
#'   p <- SOmap2(Trim = -45, IWC = TRUE, IWClab = TRUE, Grats = TRUE, fronts = TRUE)
#'   SOgg(p)
#' }
#'
#' @export
SOgg <- function(x) {
    if (!inherits(x, "SOmap")) stop("x must be an SOmap object as generated by SOmap or SOmap2")
    myext <- extent(x$target)
    ## plot bathymetry
    bdf <- raster::as.data.frame(raster::trim(SOmap::latmask(x$bathy$data, latitude = x$trim)), xy = TRUE)
    names(bdf)[3] <- "Depth"
    p <- ggplot(data = bdf, aes_string(x = "x", y = "y")) + geom_raster(aes_string(fill = "Depth"))
    if (!is.null(x$bathy_legend)) {
        p <- p + scale_fill_gradientn(colours = x$bathy$col, na.value = "#FFFFFF00")
##        raster::plot(x$bathy_legend$mask$graticule, border = x$bathy_legend$mask$border, col = x$bathy_legend$mask$col, add = TRUE) ## white mask
##        raster::plot(x$bathy_legend$ticks$ticks, add = TRUE, col = x$bathy_legend$ticks$col)
##        raster::plot(x$bathy_legend$legend$legend, lwd = x$bathy_legend$legend$lwd, add = TRUE)
##        raster::plot(x$bathy_legend$legend$legend, border = x$bathy_legend$legend$border, col = x$bathy_legend$legend$col, add = TRUE)
##        suppressMessages(this <- fortify(x$bathy_legend$legend$legend))
##        this$fill <- x$bathy_legend$legend$col[as.numeric(this$id)]
  ## nb, would have to draw each of these polygons in turn, with a fixed (non-aesthetic) fill specification? otherwise it will interfere with the scale_fill_gradientn
##        raster::plot(x$bathy_legend$graticules$graticules, border = x$bathy_legend$graticules$border, col = x$bathy_legend$graticules$col, add = TRUE)
##        text(x$bathy_legend$labels$data, labels = x$bathy_legend$labels$labels, cex = x$bathy_legend$labels$cex, adj = x$bathy_legend$labels$adj)
    } else {
        p <- p + scale_fill_gradientn(colours = x$bathy$col, na.value = "#FFFFFF00", guide = NULL)
    }

    ## buffer to use for cropping things back to our extent of interest
    buf <- sf::st_sf(a = 1, geometry = sf::st_sfc(sf::st_buffer(sf::st_point(cbind(0, 0)), 111111 * (90-abs(x$trim+2)))), crs = raster::projection(SOmap_data$continent))

    if (!is.null(x$coastline)) {
        ## the coastline data has to be trimmed to our northernmost latitude
        ## masking (using e.g. x$bathy_legend$mask$graticule) is likely to be problematic because of z-ordering
        ## TODO check that this trimming is robust
        this <- x$coastline$data
        this <- suppressWarnings(sf::st_intersection(buf, x$coastline$data))
        p <- p + geom_sf(data = this, fill = x$coastline$fillcol, col = x$coastline$linecol, inherit.aes = FALSE)
    }
    if (!is.null(x$iwc)) {
        for (ii in seq_len(length(x$iwc$data))) {
            this <- as.data.frame(x$iwc$data[[ii]])
            names(this) <- c("x", "y")
            p <- p + geom_path(data = this, col = x$iwc$col)
        }
        if (!is.null(x$iwc$labels)) {
            this <- as.data.frame(x$iwc$labels$data)
            p <- p + geom_text(data = this, aes_string(x = "lon", y = "lat", label = "a"), col = x$iwc$labels$col)##, cex = x$iwc$labels$cex, pos = x$iwc$labels$pos, offset = x$iwc$labels$offset)
        }
    }

    ## fronts
    if (!is.null(x$fronts)) {
        this <-sf::st_as_sf(x$fronts$data)
        this <- suppressWarnings(sf::st_intersection(buf, this))
        thiscol <- rep(x$fronts$col, ceiling(nrow(this)/length(x$fronts$col)))
        thiscol <- thiscol[seq_len(nrow(this))]
        p <- p + geom_sf(data = this, col = thiscol, inherit.aes = FALSE)
    }

    ## Graticule grid
    if (!is.null(x$graticule)) {
        this <- fortify(x$graticule$data)
        this <- this[this$long >= myext[1] & this$long <= myext[2] & this$lat >= myext[3] & this$lat <= myext[4], ]
        ##raster::plot(x$graticule$data, add = TRUE, col = x$graticule$col, lty = x$graticule$lty)
        p <- p + geom_path(data = this, aes_string(x = "long", y = "lat", group = "group"), col = x$graticule$col, linetype = x$graticule$lty)
        this <- as.data.frame(x$graticule$labels$data)
        this <- this[this$x >= myext[1] & this$x <= myext[2] & this$y >= myext[3] & this$y <= myext[4], ]
        p <- p + geom_text(data = this, aes_string(label = "lab"), parse = TRUE, col = x$graticule$labels$col)##, cex = x$graticule$labels$cex
    }

    p <- p + coord_sf()
    p <- p + labs() + theme(axis.title = element_blank(),
                            axis.text.x = element_blank(), axis.ticks.x = element_blank(),
                            axis.text.y = element_blank(), axis.ticks.y = element_blank(),
                            panel.border = element_blank(),
                            panel.background = element_blank())

##    plot_research_blocks(x$research_blocks)
##    plot_sprfmo(x$sprfmo_research_blocks)
##    plot_ssru(x$ccamlr_ssru)
##    plot_ssmu(x$ccamlr_ssmu)
##    plot_ccamlr_areas(x$ccamlr_statistical_areas)
##    plot_eez(x$eez)
##    plot_mpa(x$mpa)
##    plot_domains(x$ccamlr_planning_domains)

    if (!is.null(x$border)) {
        suppressMessages(this <- fortify(x$border$data))
        this$col <- (as.numeric(this$id) %% length(x$border$col)) + 1
        for (ii in seq_along(x$border$col)) {
            p <- p + geom_polygon(data = this[this$col == ii, ], aes_string(x = "long", y = "lat", group = "group"), fill = x$border$col[ii], col = "black")
        }
    }
    p
}
